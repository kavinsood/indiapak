---
description: 
globs: **/*.test.ts,**/*.test.tsx,**/*.spec.ts,**/*.spec.tsx,**/*_test.ts,**/*_spec.ts
alwaysApply: false
---
description: Guidelines for writing tests using Vitest, including unit and acceptance tests, and mocking.
globs: ["/.{test,spec}.{ts,tsx}", "/_test.ts", "/_spec.ts"] # Adjust to your project's naming
alwaysApply: false

### Testing with Vitest

1.  Test Colocation:
       Colocate test files with the source files (e.g., `utils/db.ts` â†’ `utils/db.test.ts`).
2.  Test Types:
       Unit Tests: Focus on isolating and testing individual functions or components. Mock external dependencies.
       Integration/Acceptance Tests: Test how multiple units work together. Use real dependencies or higher-level test doubles where appropriate.
3.  Test-Driven Development (TDD) Mindset:
       Write tests specifying behavior before implementation where practical.
4.  Assertion Richness:
       Use multiple, specific assertions to cover scenarios and edge cases.

### Mocking with `vi.mock` (for Unit Tests)

Rationale: Mocking is essential for unit tests to achieve isolation, speed, determinism, and control over external dependencies (APIs, databases, file system, other modules).

Placement: `vi.mock` calls are hoisted to the top of the file, so place them there, outside of `describe` or `it` blocks.

Common Patterns:

   Mocking a Module with a Factory:
       You provide an explicit mock implementation.
       Useful for complex modules or when you need fine-grained control.

    ```typescript
    // src/utils/api-client.ts
    // export const fetchUserData = async (userId: string) => {
    //   const response = await fetch(`/api/users/${userId}`);
    //   if (!response.ok) throw new Error('Network response was not ok');
    //   return response.json();
    // };

    // src/services/user-service.ts
    // import { fetchUserData } from '@/utils/api-client';
    // export const getUserDetails = async (userId: string) => {
    //   try {
    //     const data = await fetchUserData(userId);
    //     return { ...data, processed: true };
    //   } catch (error) {
    //     console.error("Failed to get user details:", error);
    //     return null;
    //   }
    // };

    // src/services/user-service.test.ts
    import { describe, it, expect, vi, beforeEach } from 'vitest';
    import { getUserDetails } from './user-service'; // The unit under test

    // Mock the api-client module
    vi.mock('@/utils/api-client', () => ({
      fetchUserData: vi.fn(), // Create a Vitest mock function
    }));

    describe('UserService - getUserDetails', () => {
      // Import the mocked version after vi.mock
      let mockedFetchUserData: ReturnType<typeof vi.fn>;

      beforeEach(async () => {
        // Dynamically import the mocked module to access the mock function instance
        const apiClient = await import('@/utils/api-client');
        mockedFetchUserData = apiClient.fetchUserData;
        mockedFetchUserData.mockReset(); // Reset mock state before each test
      });

      it('should fetch and process user data successfully', async () => {
        const mockUser = { id: '1', name: 'Test User' };
        mockedFetchUserData.mockResolvedValue(mockUser);

        const result = await getUserDetails('1');

        expect(mockedFetchUserData).toHaveBeenCalledWith('1');
        expect(result).toEqual({ ...mockUser, processed: true });
      });

      it('should return null if fetching user data fails', async () => {
        mockedFetchUserData.mockRejectedValue(new Error('API Error'));

        const result = await getUserDetails('1');

        expect(mockedFetchUserData).toHaveBeenCalledWith('1');
        expect(result).toBeNull();
      });
    });
    ```

   Mocking `server-only` or `client-only` packages:
       If you're unit testing a component that imports from `server-only` in a client-side test environment (or vice-versa), you might need to mock it to prevent errors.
    ```typescript
    // In your test file, if a component imports something from 'server-only'
    // and you are running tests in a non-server environment (e.g. JSDOM for components)
    // vi.mock('server-only', () => ({
    //   // Provide mock implementations for any exports your code uses from 'server-only'
    //   someServerFunction: vi.fn(() => 'mocked server value'),
    // }));
    ```

   Clearing/Resetting Mocks:
       `mockedFunction.mockClear()`: Clears `calls`, `instances`, `contexts` and `results` properties.
       `mockedFunction.mockReset()`: Does everything `mockClear` does, and also removes any mocked return values or implementations, resetting it to a simple `vi.fn()`. This is often preferred in `beforeEach`.
       `mockedFunction.mockRestore()`: Does everything `mockReset` does, and also restores the original (non-mocked) implementation. Useful if you used `vi.spyOn` and want to revert.
       `vi.clearAllMocks()`: Clears all mocks' call history.
       `vi.resetAllMocks()`: Resets all mocks to their empty `vi.fn()` state.
       `vi.restoreAllMocks()`: Restores original implementations for all spied methods.

### Spying with `vi.spyOn`

   Sometimes, you want to use the original implementation of a function but still track its calls or temporarily change its behavior.
   `vi.spyOn(object, 'methodName')`

    ```typescript
    // src/utils/logger.ts
    // export const logger = {
    //   log: (message: string) => console.log(message),
    //   error: (message: string) => console.error(message),
    // };

    // src/some-module.ts
    // import { logger } from '@/utils/logger';
    // export const doSomethingAndLog = (input: string) => {
    //   logger.log(`Doing something with: ${input}`);
    //   if (!input) {
    //     logger.error('Input was empty!');
    //     return false;
    //   }
    //   return true;
    // };

    // src/some-module.test.ts
    import { describe, it, expect, vi, afterEach } from 'vitest';
    import { logger } from '@/utils/logger'; // Import the actual logger
    import { doSomethingAndLog } from './some-module';

    describe('doSomethingAndLog', () => {
      const logSpy = vi.spyOn(logger, 'log');
      const errorSpy = vi.spyOn(logger, 'error');

      afterEach(() => {
        logSpy.mockClear(); // Or vi.restoreAllMocks() if you want to be thorough
        errorSpy.mockClear();
      });

      it('should log a message and return true for valid input', () => {
        const result = doSomethingAndLog('test');
        expect(logSpy).toHaveBeenCalledWith('Doing something with: test');
        expect(errorSpy).not.toHaveBeenCalled();
        expect(result).toBe(true);
      });

      it('should log an error and return false for empty input', () => {
        const result = doSomethingAndLog('');
        expect(logSpy).toHaveBeenCalledWith('Doing something with: '); // Still logs this
        expect(errorSpy).toHaveBeenCalledWith('Input was empty!');
        expect(result).toBe(false);
      });

      // You can also temporarily change implementation with a spy
      it('can mock implementation of a spied method', () => {
        logSpy.mockImplementation(() => { / do nothing / });
        doSomethingAndLog('silent test');
        expect(logSpy).toHaveBeenCalledWith('silent test');
        // console.log would not have actually run
        logSpy.mockRestore(); // Restore original console.log behavior
      });
    });
    ```
6.  React Testing (if applicable with Vitest):
       If using Vitest for React components, use `@testing-library/react`.
       Focus on testing component behavior from a user's perspective.
       Use snapshot testing only for pure presentational components to avoid brittle tests.